/**\n * Export and Sharing Service\n * Provides functionality to export OpenAPI specifications in various formats\n */\n\nimport { OpenApiDocument } from '@/common/openapi-spec';\nimport { ExportConfig } from '@/core/validation/schemas';\n\nexport interface ExportResult {\n  content: string;\n  filename: string;\n  mimeType: string;\n  size: number;\n}\n\nexport interface ShareableLink {\n  id: string;\n  url: string;\n  expiresAt?: string;\n  accessCount: number;\n  maxAccess?: number;\n  password?: string;\n  metadata: {\n    title: string;\n    version: string;\n    createdAt: string;\n  };\n}\n\n/**\n * Export Service for OpenAPI specifications\n */\nexport class ExportService {\n  private static readonly MAX_EXPORT_SIZE = 50 * 1024 * 1024; // 50MB\n  \n  /**\n   * Export OpenAPI specification in requested format\n   */\n  static async exportSpec(\n    spec: OpenApiDocument, \n    config: ExportConfig\n  ): Promise<ExportResult> {\n    const startTime = performance.now();\n    \n    try {\n      let content: string;\n      let filename: string;\n      let mimeType: string;\n      \n      // Process specification based on config\n      const processedSpec = this.preprocessSpec(spec, config);\n      \n      switch (config.format) {\n        case 'json':\n          content = this.exportToJson(processedSpec, config);\n          filename = this.generateFilename(spec, 'json');\n          mimeType = 'application/json';\n          break;\n          \n        case 'yaml':\n          content = this.exportToYaml(processedSpec, config);\n          filename = this.generateFilename(spec, 'yaml');\n          mimeType = 'application/x-yaml';\n          break;\n          \n        case 'html':\n          content = await this.exportToHtml(processedSpec, config);\n          filename = this.generateFilename(spec, 'html');\n          mimeType = 'text/html';\n          break;\n          \n        case 'postman':\n          content = this.exportToPostman(processedSpec, config);\n          filename = this.generateFilename(spec, 'json');\n          mimeType = 'application/json';\n          break;\n          \n        default:\n          throw new Error(`Unsupported export format: ${config.format}`);\n      }\n      \n      // Check size limit\n      if (content.length > this.MAX_EXPORT_SIZE) {\n        throw new Error('Export content exceeds maximum size limit');\n      }\n      \n      const endTime = performance.now();\n      console.log(`Export completed in ${Math.round(endTime - startTime)}ms`);\n      \n      return {\n        content,\n        filename,\n        mimeType,\n        size: content.length\n      };\n      \n    } catch (error) {\n      throw new Error(`Export failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n  \n  /**\n   * Preprocess specification based on export configuration\n   */\n  private static preprocessSpec(spec: OpenApiDocument, config: ExportConfig): OpenApiDocument {\n    let processedSpec = JSON.parse(JSON.stringify(spec)); // Deep clone\n    \n    // Remove examples if not included\n    if (!config.includeExamples) {\n      processedSpec = this.removeExamples(processedSpec);\n    }\n    \n    // Remove descriptions if not included\n    if (!config.includeDescriptions) {\n      processedSpec = this.removeDescriptions(processedSpec);\n    }\n    \n    // Add export metadata\n    processedSpec['x-exported-by'] = 'YASP';\n    processedSpec['x-exported-at'] = new Date().toISOString();\n    processedSpec['x-export-config'] = {\n      format: config.format,\n      includeExamples: config.includeExamples,\n      includeDescriptions: config.includeDescriptions,\n      minify: config.minify\n    };\n    \n    return processedSpec;\n  }\n  \n  /**\n   * Export to JSON format\n   */\n  private static exportToJson(spec: OpenApiDocument, config: ExportConfig): string {\n    if (config.minify) {\n      return JSON.stringify(spec);\n    } else {\n      return JSON.stringify(spec, null, 2);\n    }\n  }\n  \n  /**\n   * Export to YAML format\n   */\n  private static exportToYaml(spec: OpenApiDocument, config: ExportConfig): string {\n    // Simple YAML conversion (in a real implementation, use a YAML library)\n    // For now, we'll return formatted JSON with a note\n    const jsonContent = config.minify \n      ? JSON.stringify(spec)\n      : JSON.stringify(spec, null, 2);\n      \n    return `# OpenAPI Specification in YAML format\\n# Note: This is a JSON representation. Use a YAML converter for proper YAML output.\\n\\n${jsonContent}`;\n  }\n  \n  /**\n   * Export to HTML documentation\n   */\n  private static async exportToHtml(spec: OpenApiDocument, config: ExportConfig): Promise<string> {\n    const title = spec.info.title || 'API Documentation';\n    const version = spec.info.version || '1.0.0';\n    const description = spec.info.description || '';\n    \n    // Generate HTML documentation\n    const html = `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>${title} - API Documentation</title>\n    <style>\n        body {\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n            line-height: 1.6;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            color: #333;\n        }\n        .header {\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            color: white;\n            padding: 40px;\n            border-radius: 10px;\n            margin-bottom: 30px;\n        }\n        .header h1 {\n            margin: 0 0 10px 0;\n            font-size: 2.5em;\n        }\n        .header .version {\n            opacity: 0.9;\n            font-size: 1.1em;\n        }\n        .description {\n            background: #f8f9fa;\n            padding: 20px;\n            border-radius: 8px;\n            margin-bottom: 30px;\n            border-left: 4px solid #007bff;\n        }\n        .section {\n            margin-bottom: 40px;\n        }\n        .section h2 {\n            color: #495057;\n            border-bottom: 2px solid #e9ecef;\n            padding-bottom: 10px;\n        }\n        .path-item {\n            background: white;\n            border: 1px solid #dee2e6;\n            border-radius: 8px;\n            margin-bottom: 20px;\n            overflow: hidden;\n        }\n        .path-header {\n            background: #f8f9fa;\n            padding: 15px 20px;\n            font-weight: bold;\n            border-bottom: 1px solid #dee2e6;\n        }\n        .method {\n            display: inline-block;\n            padding: 4px 8px;\n            border-radius: 4px;\n            font-size: 0.8em;\n            font-weight: bold;\n            margin-right: 10px;\n            text-transform: uppercase;\n        }\n        .method.get { background: #28a745; color: white; }\n        .method.post { background: #007bff; color: white; }\n        .method.put { background: #ffc107; color: black; }\n        .method.delete { background: #dc3545; color: white; }\n        .method.patch { background: #6f42c1; color: white; }\n        .operation-details {\n            padding: 20px;\n        }\n        .servers {\n            background: #e3f2fd;\n            padding: 15px;\n            border-radius: 6px;\n            margin-bottom: 20px;\n        }\n        .server-item {\n            font-family: monospace;\n            background: white;\n            padding: 8px 12px;\n            border-radius: 4px;\n            margin: 5px 0;\n            border-left: 3px solid #2196f3;\n        }\n        .footer {\n            text-align: center;\n            color: #666;\n            padding: 40px 0;\n            border-top: 1px solid #eee;\n            margin-top: 40px;\n        }\n        code {\n            background: #f1f3f4;\n            padding: 2px 6px;\n            border-radius: 3px;\n            font-family: 'Monaco', 'Consolas', monospace;\n        }\n        pre {\n            background: #f8f9fa;\n            padding: 15px;\n            border-radius: 6px;\n            overflow-x: auto;\n            border: 1px solid #e9ecef;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"header\">\n        <h1>${title}</h1>\n        <div class=\"version\">Version ${version}</div>\n    </div>\n    \n    ${description ? `<div class=\"description\"><p>${description}</p></div>` : ''}\n    \n    ${this.generateServersHtml(spec)}\n    ${this.generatePathsHtml(spec, config)}\n    ${this.generateSchemasHtml(spec, config)}\n    \n    <div class=\"footer\">\n        <p>Generated by <strong>YASP</strong> on ${new Date().toLocaleDateString()}</p>\n        <p><small>OpenAPI ${spec.openapi} Specification</small></p>\n    </div>\n</body>\n</html>`;\n    \n    return html;\n  }\n  \n  /**\n   * Export to Postman collection format\n   */\n  private static exportToPostman(spec: OpenApiDocument, config: ExportConfig): string {\n    const collection = {\n      info: {\n        name: spec.info.title || 'API Collection',\n        description: spec.info.description || '',\n        version: spec.info.version || '1.0.0',\n        schema: 'https://schema.getpostman.com/json/collection/v2.1.0/collection.json'\n      },\n      item: [] as any[],\n      variable: [] as any[]\n    };\n    \n    // Add server variables\n    if (spec.servers && spec.servers.length > 0) {\n      collection.variable.push({\n        key: 'baseUrl',\n        value: spec.servers[0].url,\n        type: 'string'\n      });\n    }\n    \n    // Convert paths to Postman items\n    Object.entries(spec.paths || {}).forEach(([path, pathItem]) => {\n      if (!pathItem) return;\n      \n      const methods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head'];\n      methods.forEach(method => {\n        const operation = (pathItem as any)[method];\n        if (operation) {\n          collection.item.push(this.convertToPostmanItem(path, method, operation, spec));\n        }\n      });\n    });\n    \n    return JSON.stringify(collection, null, 2);\n  }\n  \n  /**\n   * Convert OpenAPI operation to Postman item\n   */\n  private static convertToPostmanItem(path: string, method: string, operation: any, spec: OpenApiDocument): any {\n    const item = {\n      name: operation.summary || `${method.toUpperCase()} ${path}`,\n      request: {\n        method: method.toUpperCase(),\n        header: [] as any[],\n        url: {\n          raw: `{{baseUrl}}${path}`,\n          host: ['{{baseUrl}}'],\n          path: path.split('/').filter(p => p)\n        },\n        description: operation.description || ''\n      },\n      response: [] as any[]\n    };\n    \n    // Add parameters\n    if (operation.parameters) {\n      operation.parameters.forEach((param: any) => {\n        if (param.in === 'query') {\n          if (!item.request.url.query) item.request.url.query = [];\n          item.request.url.query.push({\n            key: param.name,\n            value: param.example || '',\n            description: param.description || ''\n          });\n        } else if (param.in === 'header') {\n          item.request.header.push({\n            key: param.name,\n            value: param.example || '',\n            description: param.description || ''\n          });\n        }\n      });\n    }\n    \n    // Add request body\n    if (operation.requestBody && method !== 'get') {\n      const content = operation.requestBody.content;\n      if (content) {\n        const contentType = Object.keys(content)[0];\n        if (contentType) {\n          item.request.header.push({\n            key: 'Content-Type',\n            value: contentType\n          });\n          \n          if (contentType.includes('application/json')) {\n            const schema = content[contentType].schema;\n            const example = content[contentType].example || this.generateExampleFromSchema(schema);\n            (item.request as any).body = {\n              mode: 'raw',\n              raw: JSON.stringify(example, null, 2)\n            };\n          }\n        }\n      }\n    }\n    \n    return item;\n  }\n  \n  /**\n   * Generate HTML for servers section\n   */\n  private static generateServersHtml(spec: OpenApiDocument): string {\n    if (!spec.servers || spec.servers.length === 0) {\n      return '';\n    }\n    \n    const serversHtml = spec.servers.map(server => \n      `<div class=\"server-item\">\n        <strong>${server.url}</strong>\n        ${server.description ? `<br><small>${server.description}</small>` : ''}\n      </div>`\n    ).join('');\n    \n    return `\n    <div class=\"section\">\n        <h2>Servers</h2>\n        <div class=\"servers\">\n            ${serversHtml}\n        </div>\n    </div>`;\n  }\n  \n  /**\n   * Generate HTML for paths section\n   */\n  private static generatePathsHtml(spec: OpenApiDocument, config: ExportConfig): string {\n    const pathsHtml = Object.entries(spec.paths || {}).map(([path, pathItem]) => {\n      if (!pathItem) return '';\n      \n      const methods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head'];\n      const operationsHtml = methods.map(method => {\n        const operation = (pathItem as any)[method];\n        if (!operation) return '';\n        \n        return `\n        <div class=\"operation-details\">\n            <div style=\"margin-bottom: 15px;\">\n                <span class=\"method ${method}\">${method}</span>\n                <code>${path}</code>\n            </div>\n            ${operation.summary ? `<h4>${operation.summary}</h4>` : ''}\n            ${config.includeDescriptions && operation.description ? `<p>${operation.description}</p>` : ''}\n        </div>`;\n      }).filter(html => html).join('');\n      \n      if (!operationsHtml) return '';\n      \n      return `\n      <div class=\"path-item\">\n          <div class=\"path-header\">${path}</div>\n          ${operationsHtml}\n      </div>`;\n    }).filter(html => html).join('');\n    \n    return `\n    <div class=\"section\">\n        <h2>API Endpoints</h2>\n        ${pathsHtml}\n    </div>`;\n  }\n  \n  /**\n   * Generate HTML for schemas section\n   */\n  private static generateSchemasHtml(spec: OpenApiDocument, config: ExportConfig): string {\n    const schemas = spec.components?.schemas;\n    if (!schemas || Object.keys(schemas).length === 0) {\n      return '';\n    }\n    \n    const schemasHtml = Object.entries(schemas).map(([name, schema]) => {\n      if ('$ref' in schema) return '';\n      \n      return `\n      <div class=\"path-item\">\n          <div class=\"path-header\">${name}</div>\n          <div class=\"operation-details\">\n              ${config.includeDescriptions && schema.description ? `<p>${schema.description}</p>` : ''}\n              <pre><code>${JSON.stringify(schema, null, 2)}</code></pre>\n          </div>\n      </div>`;\n    }).filter(html => html).join('');\n    \n    return `\n    <div class=\"section\">\n        <h2>Schemas</h2>\n        ${schemasHtml}\n    </div>`;\n  }\n  \n  /**\n   * Remove examples from specification\n   */\n  private static removeExamples(spec: any): any {\n    const removeExamplesRecursively = (obj: any): any => {\n      if (Array.isArray(obj)) {\n        return obj.map(removeExamplesRecursively);\n      } else if (obj && typeof obj === 'object') {\n        const newObj: any = {};\n        for (const [key, value] of Object.entries(obj)) {\n          if (key !== 'example' && key !== 'examples') {\n            newObj[key] = removeExamplesRecursively(value);\n          }\n        }\n        return newObj;\n      }\n      return obj;\n    };\n    \n    return removeExamplesRecursively(spec);\n  }\n  \n  /**\n   * Remove descriptions from specification\n   */\n  private static removeDescriptions(spec: any): any {\n    const removeDescriptionsRecursively = (obj: any): any => {\n      if (Array.isArray(obj)) {\n        return obj.map(removeDescriptionsRecursively);\n      } else if (obj && typeof obj === 'object') {\n        const newObj: any = {};\n        for (const [key, value] of Object.entries(obj)) {\n          if (key !== 'description') {\n            newObj[key] = removeDescriptionsRecursively(value);\n          }\n        }\n        return newObj;\n      }\n      return obj;\n    };\n    \n    return removeDescriptionsRecursively(spec);\n  }\n  \n  /**\n   * Generate filename based on specification and format\n   */\n  private static generateFilename(spec: OpenApiDocument, extension: string): string {\n    const title = spec.info.title || 'openapi-spec';\n    const version = spec.info.version || '1.0.0';\n    const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD\n    \n    // Sanitize title for filename\n    const sanitizedTitle = title\n      .toLowerCase()\n      .replace(/[^a-z0-9]+/g, '-')\n      .replace(/^-+|-+$/g, '');\n    \n    return `${sanitizedTitle}-v${version}-${timestamp}.${extension}`;\n  }\n  \n  /**\n   * Generate example from schema (simplified)\n   */\n  private static generateExampleFromSchema(schema: any): any {\n    if (!schema) return {};\n    \n    if (schema.example !== undefined) {\n      return schema.example;\n    }\n    \n    if (schema.type === 'object') {\n      const example: any = {};\n      if (schema.properties) {\n        Object.entries(schema.properties).forEach(([key, prop]: [string, any]) => {\n          example[key] = this.generateExampleFromSchema(prop);\n        });\n      }\n      return example;\n    }\n    \n    if (schema.type === 'array') {\n      return [this.generateExampleFromSchema(schema.items)];\n    }\n    \n    // Return simple examples based on type\n    switch (schema.type) {\n      case 'string': return schema.format === 'email' ? 'user@example.com' : 'string';\n      case 'number': return 0;\n      case 'integer': return 0;\n      case 'boolean': return false;\n      default: return null;\n    }\n  }\n  \n  /**\n   * Download file to user's device\n   */\n  static downloadFile(result: ExportResult): void {\n    try {\n      const blob = new Blob([result.content], { type: result.mimeType });\n      const url = URL.createObjectURL(blob);\n      \n      const link = document.createElement('a');\n      link.href = url;\n      link.download = result.filename;\n      link.style.display = 'none';\n      \n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      \n      URL.revokeObjectURL(url);\n    } catch (error) {\n      throw new Error('Failed to download file');\n    }\n  }\n  \n  /**\n   * Copy content to clipboard\n   */\n  static async copyToClipboard(content: string): Promise<void> {\n    try {\n      await navigator.clipboard.writeText(content);\n    } catch (error) {\n      throw new Error('Failed to copy to clipboard');\n    }\n  }\n}\n\nexport default ExportService;