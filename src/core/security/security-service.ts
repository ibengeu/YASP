/**\n * Comprehensive Security Service\n * Implements OWASP Top 10 2021 security measures and best practices\n */\n\nimport { z } from 'zod';\n\nexport interface SecurityConfig {\n  enableCSP: boolean;\n  enableRateLimit: boolean;\n  maxRequestSize: number;\n  sessionTimeout: number;\n  enableSecureHeaders: boolean;\n  allowedOrigins: string[];\n  blockedIPs: string[];\n}\n\nexport interface SecurityEvent {\n  type: 'RATE_LIMIT' | 'INVALID_INPUT' | 'SSRF_ATTEMPT' | 'XSS_ATTEMPT' | 'INJECTION_ATTEMPT';\n  message: string;\n  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  timestamp: string;\n  ip?: string;\n  userAgent?: string;\n  details: Record<string, any>;\n}\n\n/**\n * Security Service implementing OWASP Top 10 2021 protections\n */\nexport class SecurityService {\n  private static events: SecurityEvent[] = [];\n  private static readonly MAX_EVENTS = 1000;\n  \n  private static readonly DEFAULT_CONFIG: SecurityConfig = {\n    enableCSP: true,\n    enableRateLimit: true,\n    maxRequestSize: 10 * 1024 * 1024, // 10MB\n    sessionTimeout: 3600000, // 1 hour\n    enableSecureHeaders: true,\n    allowedOrigins: ['https://localhost:3000'],\n    blockedIPs: []\n  };\n  \n  private static config: SecurityConfig = this.DEFAULT_CONFIG;\n  \n  /**\n   * Initialize security service with configuration\n   */\n  static initialize(customConfig?: Partial<SecurityConfig>): void {\n    this.config = { ...this.DEFAULT_CONFIG, ...customConfig };\n    \n    if (this.config.enableCSP) {\n      this.setupContentSecurityPolicy();\n    }\n    \n    if (this.config.enableSecureHeaders) {\n      this.setupSecureHeaders();\n    }\n    \n    // Start security monitoring\n    this.startSecurityMonitoring();\n    \n    console.info('Security service initialized with OWASP Top 10 2021 protections');\n  }\n  \n  /**\n   * A01: Broken Access Control - Validate user permissions\n   */\n  static validateAccess(resource: string, action: string, context?: any): boolean {\n    try {\n      // Implement role-based access control\n      const permissions = this.getUserPermissions(context);\n      const hasAccess = this.checkPermission(permissions, resource, action);\n      \n      if (!hasAccess) {\n        this.logSecurityEvent({\n          type: 'INVALID_INPUT',\n          message: `Access denied for ${action} on ${resource}`,\n          severity: 'MEDIUM',\n          timestamp: new Date().toISOString(),\n          details: { resource, action, context }\n        });\n      }\n      \n      return hasAccess;\n    } catch (error) {\n      this.logSecurityEvent({\n        type: 'INVALID_INPUT',\n        message: 'Access validation error',\n        severity: 'HIGH',\n        timestamp: new Date().toISOString(),\n        details: { error: error instanceof Error ? error.message : 'Unknown' }\n      });\n      return false;\n    }\n  }\n  \n  /**\n   * A02: Cryptographic Failures - Secure data handling\n   */\n  static encryptSensitiveData(data: string, key?: string): string {\n    // In a real implementation, use proper encryption\n    // For client-side demo, we'll use base64 encoding with warning\n    console.warn('Using base64 encoding - not suitable for production!');\n    return btoa(data);\n  }\n  \n  static decryptSensitiveData(encryptedData: string, key?: string): string {\n    try {\n      return atob(encryptedData);\n    } catch {\n      throw new Error('Failed to decrypt data');\n    }\n  }\n  \n  /**\n   * A03: Injection - Input validation and sanitization\n   */\n  static sanitizeInput(input: string, maxLength = 1000): string {\n    if (typeof input !== 'string') {\n      throw new Error('Input must be a string');\n    }\n    \n    // Length validation\n    if (input.length > maxLength) {\n      this.logSecurityEvent({\n        type: 'INVALID_INPUT',\n        message: `Input exceeds maximum length: ${input.length} > ${maxLength}`,\n        severity: 'MEDIUM',\n        timestamp: new Date().toISOString(),\n        details: { inputLength: input.length, maxLength }\n      });\n      throw new Error(`Input exceeds maximum length of ${maxLength} characters`);\n    }\n    \n    // Remove potentially dangerous characters\n    // eslint-disable-next-line no-control-regex\n    let sanitized = input.replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/g, '');\n    \n    // Detect and prevent common injection patterns\n    const injectionPatterns = [\n      /<script[^>]*>.*?<\\/script>/gi,\n      /javascript:/gi,\n      /on\\w+\\s*=/gi,\n      /\\$\\{.*?\\}/g,\n      /\\{\\{.*?\\}\\}/g,\n      /(union|select|insert|update|delete|drop|exec|script)/gi\n    ];\n    \n    for (const pattern of injectionPatterns) {\n      if (pattern.test(sanitized)) {\n        this.logSecurityEvent({\n          type: 'INJECTION_ATTEMPT',\n          message: 'Potential injection attempt detected',\n          severity: 'HIGH',\n          timestamp: new Date().toISOString(),\n          details: { pattern: pattern.toString(), input: input.substring(0, 100) }\n        });\n        // Remove the suspicious content\n        sanitized = sanitized.replace(pattern, '[REMOVED]');\n      }\n    }\n    \n    return sanitized;\n  }\n  \n  /**\n   * A04: Insecure Design - Validate business logic\n   */\n  static validateBusinessLogic(operation: string, data: any): boolean {\n    try {\n      switch (operation) {\n        case 'spec_upload':\n          return this.validateSpecUpload(data);\n        case 'api_test':\n          return this.validateApiTest(data);\n        case 'workspace_create':\n          return this.validateWorkspaceCreate(data);\n        default:\n          return true;\n      }\n    } catch (error) {\n      this.logSecurityEvent({\n        type: 'INVALID_INPUT',\n        message: `Business logic validation failed: ${operation}`,\n        severity: 'MEDIUM',\n        timestamp: new Date().toISOString(),\n        details: { operation, error: error instanceof Error ? error.message : 'Unknown' }\n      });\n      return false;\n    }\n  }\n  \n  /**\n   * A05: Security Misconfiguration - Secure headers and CSP\n   */\n  private static setupContentSecurityPolicy(): void {\n    const csp = [\n      \"default-src 'self'\",\n      \"script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net\",\n      \"style-src 'self' 'unsafe-inline'\",\n      \"img-src 'self' data: https:\",\n      \"font-src 'self' data:\",\n      \"connect-src 'self' https:\",\n      \"media-src 'self'\",\n      \"object-src 'none'\",\n      \"frame-src 'none'\",\n      \"worker-src 'self'\",\n      \"manifest-src 'self'\",\n      \"base-uri 'self'\",\n      \"form-action 'self'\",\n      \"frame-ancestors 'none'\",\n      \"upgrade-insecure-requests\"\n    ].join('; ');\n    \n    // In a real application, set this server-side\n    console.info('CSP Policy:', csp);\n  }\n  \n  private static setupSecureHeaders(): void {\n    const headers = {\n      'X-Content-Type-Options': 'nosniff',\n      'X-Frame-Options': 'DENY',\n      'X-XSS-Protection': '1; mode=block',\n      'Referrer-Policy': 'strict-origin-when-cross-origin',\n      'Permissions-Policy': 'camera=(), microphone=(), geolocation=()',\n      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains'\n    };\n    \n    console.info('Security headers configured:', headers);\n  }\n  \n  /**\n   * A06: Vulnerable and Outdated Components - Dependency validation\n   */\n  static validateDependencies(): Promise<{ secure: boolean; issues: string[] }> {\n    return new Promise((resolve) => {\n      // In a real implementation, integrate with npm audit or Snyk\n      const issues: string[] = [];\n      \n      // Simulate dependency check\n      setTimeout(() => {\n        resolve({ secure: true, issues });\n      }, 100);\n    });\n  }\n  \n  /**\n   * A07: Identification and Authentication Failures - Session management\n   */\n  static createSecureSession(userId: string): string {\n    const sessionData = {\n      userId,\n      createdAt: Date.now(),\n      expiresAt: Date.now() + this.config.sessionTimeout,\n      token: this.generateSecureToken()\n    };\n    \n    const sessionId = this.generateSecureToken();\n    localStorage.setItem(`session_${sessionId}`, JSON.stringify(sessionData));\n    \n    return sessionId;\n  }\n  \n  static validateSession(sessionId: string): boolean {\n    try {\n      const sessionData = localStorage.getItem(`session_${sessionId}`);\n      if (!sessionData) return false;\n      \n      const session = JSON.parse(sessionData);\n      if (Date.now() > session.expiresAt) {\n        localStorage.removeItem(`session_${sessionId}`);\n        return false;\n      }\n      \n      return true;\n    } catch {\n      return false;\n    }\n  }\n  \n  /**\n   * A08: Software and Data Integrity Failures - Content validation\n   */\n  static validateContentIntegrity(content: string, expectedHash?: string): boolean {\n    try {\n      // Basic integrity check\n      if (expectedHash) {\n        const actualHash = this.calculateHash(content);\n        return actualHash === expectedHash;\n      }\n      \n      // Check for suspicious content modifications\n      const suspiciousPatterns = [\n        /eval\\s*\\(/gi,\n        /Function\\s*\\(/gi,\n        /setTimeout\\s*\\(/gi,\n        /setInterval\\s*\\(/gi,\n        /document\\.write/gi,\n        /innerHTML/gi\n      ];\n      \n      for (const pattern of suspiciousPatterns) {\n        if (pattern.test(content)) {\n          this.logSecurityEvent({\n            type: 'INJECTION_ATTEMPT',\n            message: 'Suspicious content detected',\n            severity: 'HIGH',\n            timestamp: new Date().toISOString(),\n            details: { pattern: pattern.toString() }\n          });\n          return false;\n        }\n      }\n      \n      return true;\n    } catch {\n      return false;\n    }\n  }\n  \n  /**\n   * A09: Security Logging and Monitoring Failures - Event logging\n   */\n  static logSecurityEvent(event: SecurityEvent): void {\n    // Add metadata\n    const enrichedEvent = {\n      ...event,\n      id: this.generateSecureToken().substring(0, 8),\n      userAgent: navigator.userAgent,\n      timestamp: event.timestamp || new Date().toISOString(),\n      sessionId: this.getCurrentSessionId()\n    };\n    \n    this.events.push(enrichedEvent);\n    \n    // Limit event storage\n    if (this.events.length > this.MAX_EVENTS) {\n      this.events = this.events.slice(-this.MAX_EVENTS);\n    }\n    \n    // Log to console for development\n    if (event.severity === 'CRITICAL' || event.severity === 'HIGH') {\n      console.error('Security Event:', enrichedEvent);\n    } else {\n      console.warn('Security Event:', enrichedEvent);\n    }\n    \n    // In production, send to security monitoring service\n    this.sendToSecurityMonitoring(enrichedEvent);\n  }\n  \n  /**\n   * A10: Server-Side Request Forgery (SSRF) - URL validation\n   */\n  static validateURL(url: string, context?: string): boolean {\n    try {\n      const parsedUrl = new URL(url);\n      \n      // Protocol validation\n      if (!['http:', 'https:'].includes(parsedUrl.protocol)) {\n        this.logSecurityEvent({\n          type: 'SSRF_ATTEMPT',\n          message: `Blocked dangerous protocol: ${parsedUrl.protocol}`,\n          severity: 'HIGH',\n          timestamp: new Date().toISOString(),\n          details: { url, context }\n        });\n        return false;\n      }\n      \n      // Private IP validation\n      const hostname = parsedUrl.hostname;\n      const privatePatterns = [\n        /^10\\./,\n        /^172\\.(1[6-9]|2[0-9]|3[01])\\./,\n        /^192\\.168\\./,\n        /^127\\./,\n        /^169\\.254\\./,\n        /^localhost$/i\n      ];\n      \n      for (const pattern of privatePatterns) {\n        if (pattern.test(hostname)) {\n          this.logSecurityEvent({\n            type: 'SSRF_ATTEMPT',\n            message: `Blocked private network access: ${hostname}`,\n            severity: 'HIGH',\n            timestamp: new Date().toISOString(),\n            details: { url, context }\n          });\n          return false;\n        }\n      }\n      \n      return true;\n    } catch {\n      return false;\n    }\n  }\n  \n  /**\n   * Rate limiting implementation\n   */\n  static checkRateLimit(identifier: string, maxRequests = 100, windowMs = 60000): boolean {\n    const key = `rate_limit_${identifier}`;\n    const now = Date.now();\n    \n    let requests = JSON.parse(localStorage.getItem(key) || '[]') as number[];\n    \n    // Remove old requests outside the window\n    requests = requests.filter(time => now - time < windowMs);\n    \n    if (requests.length >= maxRequests) {\n      this.logSecurityEvent({\n        type: 'RATE_LIMIT',\n        message: `Rate limit exceeded for ${identifier}`,\n        severity: 'MEDIUM',\n        timestamp: new Date().toISOString(),\n        details: { identifier, requests: requests.length, maxRequests }\n      });\n      return false;\n    }\n    \n    requests.push(now);\n    localStorage.setItem(key, JSON.stringify(requests));\n    \n    return true;\n  }\n  \n  /**\n   * XSS Protection\n   */\n  static sanitizeHTML(html: string): string {\n    // Basic HTML sanitization\n    const div = document.createElement('div');\n    div.textContent = html;\n    return div.innerHTML;\n  }\n  \n  /**\n   * Get security events for monitoring\n   */\n  static getSecurityEvents(severity?: SecurityEvent['severity']): SecurityEvent[] {\n    if (severity) {\n      return this.events.filter(event => event.severity === severity);\n    }\n    return [...this.events];\n  }\n  \n  /**\n   * Clear security events\n   */\n  static clearSecurityEvents(): void {\n    this.events = [];\n  }\n  \n  /**\n   * Generate security report\n   */\n  static generateSecurityReport(): {\n    summary: Record<SecurityEvent['type'], number>;\n    recentEvents: SecurityEvent[];\n    recommendations: string[];\n  } {\n    const summary: Record<SecurityEvent['type'], number> = {\n      RATE_LIMIT: 0,\n      INVALID_INPUT: 0,\n      SSRF_ATTEMPT: 0,\n      XSS_ATTEMPT: 0,\n      INJECTION_ATTEMPT: 0\n    };\n    \n    this.events.forEach(event => {\n      summary[event.type]++;\n    });\n    \n    const recentEvents = this.events.slice(-10);\n    \n    const recommendations = this.generateRecommendations(summary);\n    \n    return { summary, recentEvents, recommendations };\n  }\n  \n  // Private helper methods\n  private static getUserPermissions(context?: any): string[] {\n    // Default permissions for demo\n    return ['read', 'write', 'delete'];\n  }\n  \n  private static checkPermission(permissions: string[], resource: string, action: string): boolean {\n    // Simple permission check\n    return permissions.includes(action);\n  }\n  \n  private static validateSpecUpload(data: any): boolean {\n    return data && typeof data === 'object' && data.openapi;\n  }\n  \n  private static validateApiTest(data: any): boolean {\n    return data && typeof data.url === 'string' && this.validateURL(data.url, 'api_test');\n  }\n  \n  private static validateWorkspaceCreate(data: any): boolean {\n    return data && typeof data.name === 'string' && data.name.length <= 100;\n  }\n  \n  private static generateSecureToken(): string {\n    const array = new Uint8Array(32);\n    crypto.getRandomValues(array);\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n  \n  private static calculateHash(content: string): string {\n    // Simple hash for demo - use proper crypto in production\n    let hash = 0;\n    for (let i = 0; i < content.length; i++) {\n      const char = content.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return hash.toString(36);\n  }\n  \n  private static getCurrentSessionId(): string | null {\n    // Get current session from context\n    return localStorage.getItem('current_session_id');\n  }\n  \n  private static sendToSecurityMonitoring(event: SecurityEvent): void {\n    // In production, send to SIEM or security monitoring service\n    // For demo, just store locally\n    console.info('Would send to security monitoring:', event);\n  }\n  \n  private static startSecurityMonitoring(): void {\n    // Start periodic security checks\n    setInterval(() => {\n      this.performSecurityHealthCheck();\n    }, 60000); // Every minute\n  }\n  \n  private static performSecurityHealthCheck(): void {\n    // Check for security issues\n    const recentEvents = this.events.filter(\n      event => Date.now() - new Date(event.timestamp).getTime() < 300000 // Last 5 minutes\n    );\n    \n    const highSeverityEvents = recentEvents.filter(\n      event => event.severity === 'HIGH' || event.severity === 'CRITICAL'\n    );\n    \n    if (highSeverityEvents.length > 5) {\n      console.warn('Security Alert: High number of security events detected');\n    }\n  }\n  \n  private static generateRecommendations(summary: Record<SecurityEvent['type'], number>): string[] {\n    const recommendations: string[] = [];\n    \n    if (summary.RATE_LIMIT > 10) {\n      recommendations.push('Consider implementing more aggressive rate limiting');\n    }\n    \n    if (summary.INJECTION_ATTEMPT > 0) {\n      recommendations.push('Review input validation and sanitization procedures');\n    }\n    \n    if (summary.SSRF_ATTEMPT > 0) {\n      recommendations.push('Strengthen URL validation and network access controls');\n    }\n    \n    if (summary.XSS_ATTEMPT > 0) {\n      recommendations.push('Implement Content Security Policy and output encoding');\n    }\n    \n    return recommendations;\n  }\n}\n\nexport default SecurityService;