/**\n * Advanced Search Engine for OpenAPI Specifications\n * Implements fuzzy search, filtering, and sorting capabilities\n */\n\nimport { OpenApiDocument } from '@/common/openapi-spec';\nimport { SearchQuery } from '@/core/validation/schemas';\n\nexport interface SpecSearchable {\n  id: string | number;\n  title: string;\n  version: string;\n  description?: string;\n  spec?: OpenApiDocument;\n  createdAt: string | number | Date;\n  workspaceType?: 'Personal' | 'Team' | 'Partner' | 'Public';\n  syncStatus?: 'synced' | 'syncing' | 'offline';\n  tags?: string[];\n  isDiscoverable?: boolean;\n}\n\nexport interface SearchOptions {\n  query?: string;\n  workspaceType?: string;\n  tags?: string[];\n  syncStatus?: string;\n  sortBy?: 'name' | 'recent' | 'version' | 'relevance';\n  sortOrder?: 'asc' | 'desc';\n  includeContent?: boolean;\n  maxResults?: number;\n}\n\nexport interface SearchResult {\n  item: SpecSearchable;\n  score: number;\n  matches: SearchMatch[];\n}\n\nexport interface SearchMatch {\n  field: string;\n  value: string;\n  indices: [number, number][];\n}\n\n/**\n * Fuzzy search implementation with scoring\n */\nclass FuzzyMatcher {\n  private static calculateScore(query: string, text: string): number {\n    if (!query || !text) return 0;\n    \n    const queryLower = query.toLowerCase();\n    const textLower = text.toLowerCase();\n    \n    // Exact match gets highest score\n    if (textLower === queryLower) return 1.0;\n    \n    // Starts with query gets high score\n    if (textLower.startsWith(queryLower)) return 0.9;\n    \n    // Contains query gets medium score\n    if (textLower.includes(queryLower)) return 0.7;\n    \n    // Fuzzy match scoring\n    return this.fuzzyScore(queryLower, textLower);\n  }\n  \n  private static fuzzyScore(query: string, text: string): number {\n    if (query.length > text.length) return 0;\n    if (query === text) return 1;\n    \n    let score = 0;\n    let queryIndex = 0;\n    \n    for (let i = 0; i < text.length && queryIndex < query.length; i++) {\n      if (text[i] === query[queryIndex]) {\n        score += 1 / text.length;\n        queryIndex++;\n      }\n    }\n    \n    return queryIndex === query.length ? score : 0;\n  }\n  \n  static match(query: string, text: string, threshold = 0.3): SearchMatch | null {\n    const score = this.calculateScore(query, text);\n    \n    if (score < threshold) return null;\n    \n    // Find match indices\n    const indices = this.findIndices(query.toLowerCase(), text.toLowerCase());\n    \n    return {\n      field: 'text',\n      value: text,\n      indices\n    };\n  }\n  \n  private static findIndices(query: string, text: string): [number, number][] {\n    const indices: [number, number][] = [];\n    const queryLower = query.toLowerCase();\n    const textLower = text.toLowerCase();\n    \n    let startIndex = 0;\n    while (true) {\n      const index = textLower.indexOf(queryLower, startIndex);\n      if (index === -1) break;\n      \n      indices.push([index, index + query.length]);\n      startIndex = index + 1;\n    }\n    \n    return indices;\n  }\n}\n\n/**\n * Main search engine class\n */\nexport class SpecSearchEngine {\n  private specs: SpecSearchable[] = [];\n  private searchIndex: Map<string, Set<number>> = new Map();\n  \n  constructor(specs: SpecSearchable[] = []) {\n    this.updateSpecs(specs);\n  }\n  \n  /**\n   * Update the search index with new specifications\n   */\n  updateSpecs(specs: SpecSearchable[]): void {\n    this.specs = specs;\n    this.buildSearchIndex();\n  }\n  \n  /**\n   * Build inverted index for faster searching\n   */\n  private buildSearchIndex(): void {\n    this.searchIndex.clear();\n    \n    this.specs.forEach((spec, index) => {\n      // Index title words\n      this.indexText(spec.title, index);\n      \n      // Index description words\n      if (spec.description) {\n        this.indexText(spec.description, index);\n      }\n      \n      // Index tags\n      if (spec.tags) {\n        spec.tags.forEach(tag => this.indexText(tag, index));\n      }\n      \n      // Index OpenAPI content if includeContent is enabled\n      if (spec.spec) {\n        this.indexOpenAPIContent(spec.spec, index);\n      }\n    });\n  }\n  \n  private indexText(text: string, specIndex: number): void {\n    // Tokenize and clean text\n    const tokens = this.tokenize(text);\n    \n    tokens.forEach(token => {\n      if (!this.searchIndex.has(token)) {\n        this.searchIndex.set(token, new Set());\n      }\n      this.searchIndex.get(token)!.add(specIndex);\n    });\n  }\n  \n  private indexOpenAPIContent(spec: OpenApiDocument, specIndex: number): void {\n    // Index API paths\n    Object.keys(spec.paths || {}).forEach(path => {\n      this.indexText(path, specIndex);\n    });\n    \n    // Index tags\n    spec.tags?.forEach(tag => {\n      this.indexText(tag.name, specIndex);\n      if (tag.description) {\n        this.indexText(tag.description, specIndex);\n      }\n    });\n    \n    // Index server URLs\n    spec.servers?.forEach(server => {\n      this.indexText(server.url, specIndex);\n      if (server.description) {\n        this.indexText(server.description, specIndex);\n      }\n    });\n  }\n  \n  private tokenize(text: string): string[] {\n    return text\n      .toLowerCase()\n      .replace(/[^a-z0-9\\s]/g, ' ')\n      .split(/\\s+/)\n      .filter(token => token.length > 2); // Ignore very short words\n  }\n  \n  /**\n   * Perform search with advanced filtering and scoring\n   */\n  search(options: SearchOptions): SearchResult[] {\n    let results: SearchResult[] = [];\n    \n    if (options.query && options.query.trim()) {\n      results = this.performTextSearch(options.query.trim());\n    } else {\n      // If no query, return all specs with basic score\n      results = this.specs.map((spec, index) => ({\n        item: spec,\n        score: 1.0,\n        matches: []\n      }));\n    }\n    \n    // Apply filters\n    results = this.applyFilters(results, options);\n    \n    // Sort results\n    results = this.sortResults(results, options);\n    \n    // Limit results\n    if (options.maxResults && options.maxResults > 0) {\n      results = results.slice(0, options.maxResults);\n    }\n    \n    return results;\n  }\n  \n  private performTextSearch(query: string): SearchResult[] {\n    const results: Map<number, SearchResult> = new Map();\n    const tokens = this.tokenize(query);\n    \n    // Search for each token\n    tokens.forEach(token => {\n      const matchingIndices = this.searchIndex.get(token) || new Set();\n      \n      matchingIndices.forEach(specIndex => {\n        if (!results.has(specIndex)) {\n          results.set(specIndex, {\n            item: this.specs[specIndex],\n            score: 0,\n            matches: []\n          });\n        }\n        \n        const result = results.get(specIndex)!;\n        result.score += 1 / tokens.length; // Basic TF scoring\n      });\n    });\n    \n    // Enhance scoring with fuzzy matching\n    const enhancedResults: SearchResult[] = [];\n    \n    results.forEach(result => {\n      const spec = result.item;\n      let totalScore = result.score;\n      const matches: SearchMatch[] = [];\n      \n      // Check title match\n      const titleMatch = FuzzyMatcher.match(query, spec.title);\n      if (titleMatch) {\n        titleMatch.field = 'title';\n        matches.push(titleMatch);\n        totalScore += 2.0; // Title matches get higher weight\n      }\n      \n      // Check description match\n      if (spec.description) {\n        const descMatch = FuzzyMatcher.match(query, spec.description);\n        if (descMatch) {\n          descMatch.field = 'description';\n          matches.push(descMatch);\n          totalScore += 1.0;\n        }\n      }\n      \n      // Check tag matches\n      if (spec.tags) {\n        spec.tags.forEach(tag => {\n          const tagMatch = FuzzyMatcher.match(query, tag);\n          if (tagMatch) {\n            tagMatch.field = 'tag';\n            tagMatch.value = tag;\n            matches.push(tagMatch);\n            totalScore += 1.5; // Tag matches get medium weight\n          }\n        });\n      }\n      \n      if (matches.length > 0 || totalScore > 0) {\n        enhancedResults.push({\n          item: spec,\n          score: totalScore,\n          matches\n        });\n      }\n    });\n    \n    return enhancedResults;\n  }\n  \n  private applyFilters(results: SearchResult[], options: SearchOptions): SearchResult[] {\n    return results.filter(result => {\n      const spec = result.item;\n      \n      // Workspace type filter\n      if (options.workspaceType && spec.workspaceType !== options.workspaceType) {\n        return false;\n      }\n      \n      // Sync status filter\n      if (options.syncStatus && spec.syncStatus !== options.syncStatus) {\n        return false;\n      }\n      \n      // Tags filter (spec must have ALL specified tags)\n      if (options.tags && options.tags.length > 0) {\n        const specTags = spec.tags || [];\n        const hasAllTags = options.tags.every(tag => \n          specTags.some(specTag => \n            specTag.toLowerCase().includes(tag.toLowerCase())\n          )\n        );\n        if (!hasAllTags) {\n          return false;\n        }\n      }\n      \n      return true;\n    });\n  }\n  \n  private sortResults(results: SearchResult[], options: SearchOptions): SearchResult[] {\n    const sortBy = options.sortBy || 'relevance';\n    const sortOrder = options.sortOrder || 'desc';\n    const multiplier = sortOrder === 'asc' ? 1 : -1;\n    \n    return results.sort((a, b) => {\n      let comparison = 0;\n      \n      switch (sortBy) {\n        case 'relevance':\n          comparison = a.score - b.score;\n          break;\n        case 'name':\n          comparison = a.item.title.localeCompare(b.item.title);\n          break;\n        case 'recent':\n          const aDate = new Date(a.item.createdAt).getTime();\n          const bDate = new Date(b.item.createdAt).getTime();\n          comparison = aDate - bDate;\n          break;\n        case 'version':\n          comparison = a.item.version.localeCompare(b.item.version, undefined, {\n            numeric: true,\n            sensitivity: 'base'\n          });\n          break;\n      }\n      \n      return comparison * multiplier;\n    });\n  }\n  \n  /**\n   * Get search suggestions based on partial query\n   */\n  getSuggestions(partialQuery: string, limit = 10): string[] {\n    if (!partialQuery || partialQuery.length < 2) {\n      return [];\n    }\n    \n    const suggestions = new Set<string>();\n    const queryLower = partialQuery.toLowerCase();\n    \n    // Get suggestions from search index\n    for (const [token] of this.searchIndex) {\n      if (token.startsWith(queryLower) && token !== queryLower) {\n        suggestions.add(token);\n        if (suggestions.size >= limit) break;\n      }\n    }\n    \n    // Get suggestions from spec titles\n    this.specs.forEach(spec => {\n      const words = this.tokenize(spec.title);\n      words.forEach(word => {\n        if (word.startsWith(queryLower) && word !== queryLower) {\n          suggestions.add(word);\n        }\n      });\n    });\n    \n    return Array.from(suggestions).slice(0, limit).sort();\n  }\n  \n  /**\n   * Get available filter options\n   */\n  getFilterOptions(): {\n    workspaceTypes: string[];\n    syncStatuses: string[];\n    tags: string[];\n  } {\n    const workspaceTypes = new Set<string>();\n    const syncStatuses = new Set<string>();\n    const tags = new Set<string>();\n    \n    this.specs.forEach(spec => {\n      if (spec.workspaceType) workspaceTypes.add(spec.workspaceType);\n      if (spec.syncStatus) syncStatuses.add(spec.syncStatus);\n      if (spec.tags) spec.tags.forEach(tag => tags.add(tag));\n    });\n    \n    return {\n      workspaceTypes: Array.from(workspaceTypes).sort(),\n      syncStatuses: Array.from(syncStatuses).sort(),\n      tags: Array.from(tags).sort()\n    };\n  }\n  \n  /**\n   * Get search statistics\n   */\n  getStats(): {\n    totalSpecs: number;\n    indexedTerms: number;\n    averageSpecSize: number;\n  } {\n    const totalSpecs = this.specs.length;\n    const indexedTerms = this.searchIndex.size;\n    const averageSpecSize = totalSpecs > 0 \n      ? this.specs.reduce((acc, spec) => {\n          const size = JSON.stringify(spec.spec || {}).length;\n          return acc + size;\n        }, 0) / totalSpecs\n      : 0;\n    \n    return {\n      totalSpecs,\n      indexedTerms,\n      averageSpecSize: Math.round(averageSpecSize)\n    };\n  }\n}