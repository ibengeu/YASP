/**\n * Editor Validation Service\n * Provides real-time validation and error reporting for OpenAPI specifications\n */\n\nimport { OpenAPISpecSchema } from '@/core/validation/schemas';\nimport { OpenApiDocument } from '@/common/openapi-spec';\n\nexport interface ValidationError {\n  line: number;\n  column: number;\n  message: string;\n  severity: 'error' | 'warning' | 'info';\n  code: string;\n  path: string[];\n  suggestion?: string;\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: ValidationError[];\n  warnings: ValidationError[];\n  info: ValidationError[];\n  performance: {\n    validationTime: number;\n    linesProcessed: number;\n  };\n}\n\n/**\n * OpenAPI Editor Validation Service\n */\nexport class EditorValidationService {\n  private static readonly MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\n  private static readonly VALIDATION_TIMEOUT = 5000; // 5 seconds\n  \n  /**\n   * Validate JSON content with comprehensive error reporting\n   */\n  static async validateContent(content: string): Promise<ValidationResult> {\n    const startTime = performance.now();\n    const result: ValidationResult = {\n      isValid: false,\n      errors: [],\n      warnings: [],\n      info: [],\n      performance: {\n        validationTime: 0,\n        linesProcessed: 0\n      }\n    };\n    \n    try {\n      // Check file size\n      if (content.length > this.MAX_FILE_SIZE) {\n        result.errors.push({\n          line: 1,\n          column: 1,\n          message: 'File size exceeds 10MB limit',\n          severity: 'error',\n          code: 'FILE_TOO_LARGE',\n          path: [],\n          suggestion: 'Reduce file size or split into smaller specifications'\n        });\n        return result;\n      }\n      \n      const lines = content.split('\\n');\n      result.performance.linesProcessed = lines.length;\n      \n      // Parse JSON\n      let parsedContent: unknown;\n      try {\n        parsedContent = JSON.parse(content);\n      } catch (error) {\n        const parseError = this.parseJsonError(error as SyntaxError, content);\n        result.errors.push(parseError);\n        return result;\n      }\n      \n      // Validate OpenAPI schema\n      const schemaValidation = OpenAPISpecSchema.safeParse(parsedContent);\n      \n      if (schemaValidation.success) {\n        result.isValid = true;\n        \n        // Add informational messages\n        const spec = schemaValidation.data as OpenApiDocument;\n        this.addInfoMessages(spec, result);\n        this.addWarningMessages(spec, result, content);\n      } else {\n        // Convert Zod errors to validation errors\n        result.errors.push(...this.convertZodErrors(schemaValidation.error.errors, content));\n      }\n      \n      // Additional semantic validation\n      if (result.isValid) {\n        await this.performSemanticValidation(parsedContent as OpenApiDocument, result, content);\n      }\n      \n    } catch (error) {\n      result.errors.push({\n        line: 1,\n        column: 1,\n        message: error instanceof Error ? error.message : 'Unknown validation error',\n        severity: 'error',\n        code: 'VALIDATION_ERROR',\n        path: []\n      });\n    }\n    \n    const endTime = performance.now();\n    result.performance.validationTime = Math.round(endTime - startTime);\n    \n    return result;\n  }\n  \n  /**\n   * Parse JSON syntax errors and convert to validation errors\n   */\n  private static parseJsonError(error: SyntaxError, content: string): ValidationError {\n    const message = error.message;\n    let line = 1;\n    let column = 1;\n    let suggestion = 'Check JSON syntax';\n    \n    // Extract position from error message\n    const positionMatch = message.match(/at position (\\d+)/);\n    if (positionMatch) {\n      const position = parseInt(positionMatch[1], 10);\n      const lines = content.substring(0, position).split('\\n');\n      line = lines.length;\n      column = lines[lines.length - 1].length + 1;\n    }\n    \n    // Provide specific suggestions based on error type\n    if (message.includes('Unexpected token')) {\n      suggestion = 'Check for missing commas, quotes, or brackets';\n    } else if (message.includes('Unterminated string')) {\n      suggestion = 'Check for unclosed string quotes';\n    } else if (message.includes('Unexpected end of JSON')) {\n      suggestion = 'Check for missing closing brackets or braces';\n    }\n    \n    return {\n      line,\n      column,\n      message: `JSON Syntax Error: ${message}`,\n      severity: 'error',\n      code: 'JSON_SYNTAX_ERROR',\n      path: [],\n      suggestion\n    };\n  }\n  \n  /**\n   * Convert Zod validation errors to editor validation errors\n   */\n  private static convertZodErrors(errors: any[], content: string): ValidationError[] {\n    const lines = content.split('\\n');\n    \n    return errors.map(error => {\n      const path = error.path || [];\n      const { line, column } = this.findPathInContent(path, content, lines);\n      \n      let suggestion: string | undefined;\n      const code = error.code || 'SCHEMA_ERROR';\n      \n      // Provide specific suggestions based on error type\n      switch (code) {\n        case 'invalid_type':\n          suggestion = `Expected ${error.expected}, got ${error.received}`;\n          break;\n        case 'too_small':\n          suggestion = `Minimum ${error.minimum} ${error.type} required`;\n          break;\n        case 'too_big':\n          suggestion = `Maximum ${error.maximum} ${error.type} allowed`;\n          break;\n        case 'invalid_string':\n          if (error.validation === 'url') {\n            suggestion = 'Provide a valid URL (e.g., https://api.example.com)';\n          } else if (error.validation === 'email') {\n            suggestion = 'Provide a valid email address';\n          }\n          break;\n        case 'unrecognized_keys':\n          suggestion = 'Remove unknown properties or check spelling';\n          break;\n      }\n      \n      return {\n        line,\n        column,\n        message: error.message,\n        severity: 'error',\n        code,\n        path,\n        suggestion\n      };\n    });\n  }\n  \n  /**\n   * Find line and column for a JSON path in content\n   */\n  private static findPathInContent(path: (string | number)[], content: string, lines: string[]): { line: number; column: number } {\n    if (path.length === 0) {\n      return { line: 1, column: 1 };\n    }\n    \n    try {\n      // Simple heuristic to find the path in content\n      const pathString = path.join('.');\n      const searchKey = typeof path[path.length - 1] === 'string' ? path[path.length - 1] : '';\n      \n      if (searchKey) {\n        const quotedKey = `\"${searchKey}\"`;\n        for (let i = 0; i < lines.length; i++) {\n          const line = lines[i];\n          const index = line.indexOf(quotedKey);\n          if (index !== -1) {\n            return { line: i + 1, column: index + 1 };\n          }\n        }\n      }\n      \n      return { line: 1, column: 1 };\n    } catch {\n      return { line: 1, column: 1 };\n    }\n  }\n  \n  /**\n   * Add informational messages about the specification\n   */\n  private static addInfoMessages(spec: OpenApiDocument, result: ValidationResult): void {\n    // OpenAPI version info\n    result.info.push({\n      line: 1,\n      column: 1,\n      message: `OpenAPI ${spec.openapi} specification detected`,\n      severity: 'info',\n      code: 'OPENAPI_VERSION',\n      path: ['openapi']\n    });\n    \n    // Path count\n    const pathCount = Object.keys(spec.paths || {}).length;\n    result.info.push({\n      line: 1,\n      column: 1,\n      message: `${pathCount} API path${pathCount !== 1 ? 's' : ''} defined`,\n      severity: 'info',\n      code: 'PATH_COUNT',\n      path: ['paths']\n    });\n    \n    // Schema count\n    const schemaCount = Object.keys(spec.components?.schemas || {}).length;\n    if (schemaCount > 0) {\n      result.info.push({\n        line: 1,\n        column: 1,\n        message: `${schemaCount} schema${schemaCount !== 1 ? 's' : ''} defined`,\n        severity: 'info',\n        code: 'SCHEMA_COUNT',\n        path: ['components', 'schemas']\n      });\n    }\n  }\n  \n  /**\n   * Add warning messages for best practices\n   */\n  private static addWarningMessages(spec: OpenApiDocument, result: ValidationResult, content: string): void {\n    // Missing description\n    if (!spec.info.description) {\n      result.warnings.push({\n        line: 1,\n        column: 1,\n        message: 'API description is recommended for better documentation',\n        severity: 'warning',\n        code: 'MISSING_DESCRIPTION',\n        path: ['info', 'description'],\n        suggestion: 'Add a description field to the info object'\n      });\n    }\n    \n    // Missing servers\n    if (!spec.servers || spec.servers.length === 0) {\n      result.warnings.push({\n        line: 1,\n        column: 1,\n        message: 'Server information is recommended for API testing',\n        severity: 'warning',\n        code: 'MISSING_SERVERS',\n        path: ['servers'],\n        suggestion: 'Add at least one server URL'\n      });\n    }\n    \n    // Missing tags\n    const pathsWithoutTags = this.findPathsWithoutTags(spec);\n    if (pathsWithoutTags.length > 0) {\n      result.warnings.push({\n        line: 1,\n        column: 1,\n        message: `${pathsWithoutTags.length} operation${pathsWithoutTags.length !== 1 ? 's' : ''} without tags`,\n        severity: 'warning',\n        code: 'OPERATIONS_WITHOUT_TAGS',\n        path: ['paths'],\n        suggestion: 'Add tags to operations for better organization'\n      });\n    }\n    \n    // Large file warning\n    if (content.length > 1024 * 1024) { // 1MB\n      result.warnings.push({\n        line: 1,\n        column: 1,\n        message: 'Large specification file may impact performance',\n        severity: 'warning',\n        code: 'LARGE_FILE',\n        path: [],\n        suggestion: 'Consider splitting into multiple files using references'\n      });\n    }\n  }\n  \n  /**\n   * Perform semantic validation beyond schema validation\n   */\n  private static async performSemanticValidation(\n    spec: OpenApiDocument, \n    result: ValidationResult, \n    content: string\n  ): Promise<void> {\n    // Check for unused components\n    const unusedComponents = this.findUnusedComponents(spec, content);\n    unusedComponents.forEach(component => {\n      result.warnings.push({\n        line: 1,\n        column: 1,\n        message: `Unused component: ${component}`,\n        severity: 'warning',\n        code: 'UNUSED_COMPONENT',\n        path: ['components', 'schemas', component],\n        suggestion: 'Remove unused component or add reference'\n      });\n    });\n    \n    // Check for duplicate operation IDs\n    const duplicateOperationIds = this.findDuplicateOperationIds(spec);\n    duplicateOperationIds.forEach(operationId => {\n      result.errors.push({\n        line: 1,\n        column: 1,\n        message: `Duplicate operation ID: ${operationId}`,\n        severity: 'error',\n        code: 'DUPLICATE_OPERATION_ID',\n        path: ['paths'],\n        suggestion: 'Ensure all operation IDs are unique'\n      });\n    });\n    \n    // Check for broken references\n    const brokenRefs = this.findBrokenReferences(spec);\n    brokenRefs.forEach(ref => {\n      result.errors.push({\n        line: 1,\n        column: 1,\n        message: `Broken reference: ${ref}`,\n        severity: 'error',\n        code: 'BROKEN_REFERENCE',\n        path: [],\n        suggestion: 'Check reference path and ensure component exists'\n      });\n    });\n  }\n  \n  /**\n   * Find paths without tags\n   */\n  private static findPathsWithoutTags(spec: OpenApiDocument): string[] {\n    const pathsWithoutTags: string[] = [];\n    \n    Object.entries(spec.paths || {}).forEach(([path, pathItem]) => {\n      if (!pathItem) return;\n      \n      const operations = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head', 'trace'];\n      operations.forEach(method => {\n        const operation = (pathItem as any)[method];\n        if (operation && (!operation.tags || operation.tags.length === 0)) {\n          pathsWithoutTags.push(`${method.toUpperCase()} ${path}`);\n        }\n      });\n    });\n    \n    return pathsWithoutTags;\n  }\n  \n  /**\n   * Find unused components\n   */\n  private static findUnusedComponents(spec: OpenApiDocument, content: string): string[] {\n    const unused: string[] = [];\n    const componentNames = Object.keys(spec.components?.schemas || {});\n    \n    componentNames.forEach(name => {\n      const ref = `#/components/schemas/${name}`;\n      // Simple text search for references\n      if (!content.includes(ref) || content.indexOf(ref) === content.lastIndexOf(ref)) {\n        // Only one occurrence (the definition itself)\n        unused.push(name);\n      }\n    });\n    \n    return unused;\n  }\n  \n  /**\n   * Find duplicate operation IDs\n   */\n  private static findDuplicateOperationIds(spec: OpenApiDocument): string[] {\n    const operationIds: string[] = [];\n    const duplicates: string[] = [];\n    \n    Object.values(spec.paths || {}).forEach(pathItem => {\n      if (!pathItem) return;\n      \n      const operations = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head', 'trace'];\n      operations.forEach(method => {\n        const operation = (pathItem as any)[method];\n        if (operation?.operationId) {\n          if (operationIds.includes(operation.operationId)) {\n            duplicates.push(operation.operationId);\n          } else {\n            operationIds.push(operation.operationId);\n          }\n        }\n      });\n    });\n    \n    return duplicates;\n  }\n  \n  /**\n   * Find broken references\n   */\n  private static findBrokenReferences(spec: OpenApiDocument): string[] {\n    const broken: string[] = [];\n    const content = JSON.stringify(spec);\n    \n    // Find all $ref occurrences\n    const refMatches = content.match(/\"\\$ref\"\\s*:\\s*\"([^\"]+)\"/g) || [];\n    \n    refMatches.forEach(match => {\n      const refMatch = match.match(/\"\\$ref\"\\s*:\\s*\"([^\"]+)\"/);\n      if (refMatch) {\n        const ref = refMatch[1];\n        \n        // Check if internal reference exists\n        if (ref.startsWith('#/')) {\n          const path = ref.replace('#/', '').split('/');\n          \n          let current: any = spec;\n          let exists = true;\n          \n          for (const segment of path) {\n            if (current && typeof current === 'object' && segment in current) {\n              current = current[segment];\n            } else {\n              exists = false;\n              break;\n            }\n          }\n          \n          if (!exists) {\n            broken.push(ref);\n          }\n        }\n      }\n    });\n    \n    return [...new Set(broken)]; // Remove duplicates\n  }\n  \n  /**\n   * Get validation statistics\n   */\n  static getValidationStats(result: ValidationResult): {\n    totalIssues: number;\n    errorCount: number;\n    warningCount: number;\n    infoCount: number;\n    validationScore: number; // 0-100\n  } {\n    const errorCount = result.errors.length;\n    const warningCount = result.warnings.length;\n    const infoCount = result.info.length;\n    const totalIssues = errorCount + warningCount;\n    \n    // Calculate validation score (100 = perfect, 0 = many issues)\n    let score = 100;\n    score -= errorCount * 20; // Each error -20 points\n    score -= warningCount * 5; // Each warning -5 points\n    score = Math.max(0, score); // Don't go below 0\n    \n    return {\n      totalIssues,\n      errorCount,\n      warningCount,\n      infoCount,\n      validationScore: score\n    };\n  }\n}\n\nexport default EditorValidationService;